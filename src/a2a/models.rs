//! Complex model definitions for the A2A protocol
//! 
//! This module contains the more complex data structures used in the A2A protocol,
//! including tasks, artifacts, agent cards, and various request/response types.

use crate::a2a::core_types::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use url::Url;
use uuid::Uuid;

/// Authentication schemes for agent security
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum SecurityScheme {
    /// HTTP authentication schemes (Basic, Bearer, etc.)
    HTTPAuth(HTTPAuthSecurityScheme),
    /// OAuth2 authentication
    OAuth2(OAuth2SecurityScheme),
    /// OpenID Connect authentication
    OpenIdConnect(OpenIdConnectSecurityScheme),
    /// API key authentication
    APIKey(APIKeySecurityScheme),
    /// Mutual TLS authentication
    MutualTLS(MutualTLSSecurityScheme),
}

/// HTTP authentication scheme
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct HTTPAuthSecurityScheme {
    /// The HTTP authentication scheme (e.g., "basic", "bearer", "digest")
    pub scheme: String,
    /// A description of the authentication scheme
    pub description: Option<String>,
    /// The format of the bearer token (e.g., "JWT")
    pub bearer_format: Option<String>,
}

/// OAuth2 authentication scheme
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct OAuth2SecurityScheme {
    /// The OAuth2 flows configuration
    pub flows: HashMap<String, serde_json::Value>,
    /// A description of the OAuth2 configuration
    pub description: Option<String>,
}

/// OpenID Connect authentication scheme
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct OpenIdConnectSecurityScheme {
    /// The OpenID Connect discovery URL
    pub open_id_connect_url: String,
    /// A description of the OpenID Connect configuration
    pub description: Option<String>,
}

/// API key authentication scheme
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct APIKeySecurityScheme {
    /// The name of the API key parameter
    pub name: String,
    /// The location of the API key
    #[serde(rename = "in")]
    pub in_: In,
    /// A description of the API key
    pub description: Option<String>,
}

/// Mutual TLS authentication scheme
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MutualTLSSecurityScheme {
    /// A description of the mutual TLS configuration
    pub description: Option<String>,
}

/// Simplified skill representation for creating agents
pub struct Skill {
    pub id: String,
    pub tags: HashMap<String, serde_json::Value>,
    pub description: Option<String>,
}

impl Skill {
    pub fn new(id: String, tags: HashMap<String, serde_json::Value>, description: Option<String>) -> Self {
        Self { id, tags, description }
    }
}

/// Represents a file, data structure, or other resource generated by an agent during a task
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Artifact {
    /// A unique identifier (e.g. UUID) for the artifact within the scope of the task
    #[serde(rename = "artifact_id")]
    pub artifact_id: String,
    /// An optional, human-readable name for the artifact
    pub name: Option<String>,
    /// An optional, human-readable description of the artifact
    pub description: Option<String>,
    /// An array of content parts that make up the artifact
    pub parts: Vec<Part>,
    /// Optional metadata for extensions
    pub metadata: Option<HashMap<String, serde_json::Value>>,
    /// The URIs of extensions that are relevant to this artifact
    pub extensions: Option<Vec<String>>,
}

impl Artifact {
    pub fn new(parts: Vec<Part>) -> Self {
        Self {
            artifact_id: Uuid::new_v4().to_string(),
            name: None,
            description: None,
            parts,
            metadata: None,
            extensions: None,
        }
    }

    pub fn with_artifact_id(mut self, artifact_id: String) -> Self {
        self.artifact_id = artifact_id;
        self
    }

    pub fn with_name(mut self, name: String) -> Self {
        self.name = Some(name);
        self
    }

    pub fn with_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// Enum that can represent either a Task or a Message
/// This is useful for API responses that can return either type
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "kind", rename_all = "kebab-case")]
pub enum TaskOrMessage {
    /// A task response
    Task(Task),
    /// A message response
    Message(Message),
    /// A task status update event
    #[serde(alias = "task-status-update", rename = "status-update")]
    TaskUpdate(TaskStatusUpdateEvent),
    /// A task artifact update event
    #[serde(rename = "artifact-update")]
    TaskArtifactUpdateEvent(TaskArtifactUpdateEvent),
}

impl TaskOrMessage {
    /// Check if this is a Task
    pub fn is_task(&self) -> bool {
        matches!(self, TaskOrMessage::Task(_))
    }
    
    /// Check if this is a Message
    pub fn is_message(&self) -> bool {
        matches!(self, TaskOrMessage::Message(_))
    }
    
    /// Check if this is a Task update
    pub fn is_task_update(&self) -> bool {
        matches!(self, TaskOrMessage::TaskUpdate(_))
    }
    
    /// Check if this is an Artifact update
    pub fn is_artifact_update(&self) -> bool {
        matches!(self, TaskOrMessage::TaskArtifactUpdateEvent(_))
    }
    
    /// Get as Task reference
    pub fn as_task(&self) -> Option<&Task> {
        match self {
            TaskOrMessage::Task(task) => Some(task),
            _ => None,
        }
    }
    
    /// Get as Message reference
    pub fn as_message(&self) -> Option<&Message> {
        match self {
            TaskOrMessage::Message(message) => Some(message),
            _ => None,
        }
    }
    
    /// Get as TaskUpdate reference
    pub fn as_task_update(&self) -> Option<&TaskStatusUpdateEvent> {
        match self {
            TaskOrMessage::TaskUpdate(update) => Some(update),
            _ => None,
        }
    }
    
    /// Get as ArtifactUpdate reference
    pub fn as_artifact_update(&self) -> Option<&TaskArtifactUpdateEvent> {
        match self {
            TaskOrMessage::TaskArtifactUpdateEvent(update) => Some(update),
            _ => None,
        }
    }
}

/// Represents the service provider of an agent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentProvider {
    /// The name of the agent provider's organization
    pub organization: String,
    /// A URL for the agent provider's website or relevant documentation
    pub url: String,
}

impl AgentProvider {
    pub fn new(organization: String, url: String) -> Self {
        Self { organization, url }
    }
}

/// Represents a distinct capability or function that an agent can perform
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentSkill {
    /// A unique identifier for the agent's skill
    pub id: String,
    /// A human-readable name for the skill
    pub name: String,
    /// A detailed description of the skill
    pub description: String,
    /// A set of keywords describing the skill's capabilities
    pub tags: Vec<String>,
    /// Example prompts or scenarios that this skill can handle
    pub examples: Option<Vec<String>>,
    /// The set of supported input MIME types for this skill
    #[serde(rename = "input_modes")]
    pub input_modes: Option<Vec<String>>,
    /// The set of supported output MIME types for this skill
    #[serde(rename = "output_modes")]
    pub output_modes: Option<Vec<String>>,
    /// Security schemes necessary for the agent to leverage this skill
    pub security: Option<Vec<HashMap<String, Vec<String>>>>,
}

impl AgentSkill {
    pub fn new(id: String, name: String, description: String, tags: Vec<String>) -> Self {
        Self {
            id,
            name,
            description,
            tags,
            examples: None,
            input_modes: None,
            output_modes: None,
            security: None,
        }
    }

    pub fn with_examples(mut self, examples: Vec<String>) -> Self {
        self.examples = Some(examples);
        self
    }

    pub fn with_input_modes(mut self, modes: Vec<String>) -> Self {
        self.input_modes = Some(modes);
        self
    }

    pub fn with_output_modes(mut self, modes: Vec<String>) -> Self {
        self.output_modes = Some(modes);
        self
    }

    pub fn with_security(mut self, security: Vec<HashMap<String, Vec<String>>>) -> Self {
        self.security = Some(security);
        self
    }
}

/// A declaration of a protocol extension supported by an Agent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentExtension {
    /// The unique URI identifying the extension
    pub uri: String,
    /// A human-readable description of how this agent uses the extension
    pub description: Option<String>,
    /// If true, the client must understand and comply with the extension's requirements
    pub required: Option<bool>,
    /// Optional, extension-specific configuration parameters
    pub params: Option<HashMap<String, serde_json::Value>>,
}

impl AgentExtension {
    pub fn new(uri: String) -> Self {
        Self {
            uri,
            description: None,
            required: None,
            params: None,
        }
    }

    pub fn with_description(mut self, description: String) -> Self {
        self.description = Some(description);
        self
    }

    pub fn with_required(mut self, required: bool) -> Self {
        self.required = Some(required);
        self
    }

    pub fn with_params(mut self, params: HashMap<String, serde_json::Value>) -> Self {
        self.params = Some(params);
        self
    }
}

/// Defines optional capabilities supported by an agent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentCapabilities {
    /// Indicates if the agent supports Server-Sent Events (SSE) for streaming responses
    pub streaming: Option<bool>,
    /// Indicates if the agent supports sending push notifications for asynchronous task updates
    #[serde(rename = "push_notifications")]
    pub push_notifications: Option<bool>,
    /// Indicates if the agent provides a history of state transitions for a task
    #[serde(rename = "state_transition_history")]
    pub state_transition_history: Option<bool>,
    /// A list of protocol extensions supported by the agent
    pub extensions: Option<Vec<AgentExtension>>,
}

impl AgentCapabilities {
    pub fn new() -> Self {
        Self {
            streaming: None,
            push_notifications: None,
            state_transition_history: None,
            extensions: None,
        }
    }

    pub fn with_streaming(mut self, streaming: bool) -> Self {
        self.streaming = Some(streaming);
        self
    }

    pub fn with_push_notifications(mut self, push_notifications: bool) -> Self {
        self.push_notifications = Some(push_notifications);
        self
    }

    pub fn with_state_transition_history(mut self, state_transition_history: bool) -> Self {
        self.state_transition_history = Some(state_transition_history);
        self
    }

    pub fn with_extensions(mut self, extensions: Vec<AgentExtension>) -> Self {
        self.extensions = Some(extensions);
        self
    }
}

/// Declares a combination of a target URL and a transport protocol for interacting with an agent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentInterface {
    /// The URL where this interface is available
    pub url: String,
    /// The transport protocol supported at this URL
    pub transport: String,
}

impl AgentInterface {
    pub fn new(url: String, transport: String) -> Self {
        Self { url, transport }
    }
}

/// The AgentCard is a self-describing manifest for an agent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentCard {
    /// A human-readable name for the agent
    pub name: String,
    /// A human-readable description of the agent
    pub description: String,
    /// The preferred endpoint URL for interacting with the agent
    pub url: String,
    /// The agent's own version number
    pub version: String,
    /// The version of the A2A protocol this agent supports
    #[serde(rename = "protocol_version")]
    pub protocol_version: Option<String>,
    /// An optional URL to an icon for the agent
    #[serde(rename = "icon_url")]
    pub icon_url: Option<String>,
    /// An optional URL to the agent's documentation
    #[serde(rename = "documentation_url")]
    pub documentation_url: Option<String>,
    /// Information about the agent's service provider
    pub provider: Option<AgentProvider>,
    /// The transport protocol for the preferred endpoint
    #[serde(rename = "preferred_transport")]
    pub preferred_transport: Option<String>,
    /// A list of additional supported interfaces
    #[serde(rename = "additional_interfaces")]
    pub additional_interfaces: Option<Vec<AgentInterface>>,
    /// Default set of supported input MIME types for all skills
    #[serde(rename = "default_input_modes")]
    pub default_input_modes: Vec<String>,
    /// Default set of supported output MIME types for all skills
    #[serde(rename = "default_output_modes")]
    pub default_output_modes: Vec<String>,
    /// A declaration of optional capabilities supported by the agent
    pub capabilities: AgentCapabilities,
    /// The set of skills that the agent can perform
    pub skills: Vec<AgentSkill>,
    /// A list of security requirement objects that apply to all agent interactions
    pub security: Option<Vec<HashMap<String, Vec<String>>>>,
    /// A declaration of the security schemes available to authorize requests
    #[serde(rename = "security_schemes")]
    pub security_schemes: Option<HashMap<String, SecurityScheme>>,
    /// JSON Web Signatures computed for this AgentCard
    pub signatures: Option<Vec<serde_json::Value>>,
    /// If true, the agent can provide an extended agent card with additional details to authenticated users
    #[serde(rename = "supports_authenticated_extended_card")]
    pub supports_authenticated_extended_card: Option<bool>,
}

impl AgentCard {
    pub fn new(
        name: String,
        description: String,
        url: String,
        version: String,
        default_input_modes: Vec<String>,
        default_output_modes: Vec<String>,
        capabilities: AgentCapabilities,
        skills: Vec<AgentSkill>,
    ) -> Self {
        Self {
            name,
            description,
            url,
            version,
            protocol_version: None,
            icon_url: None,
            documentation_url: None,
            provider: None,
            preferred_transport: None,
            additional_interfaces: None,
            default_input_modes,
            default_output_modes,
            capabilities,
            skills,
            security: None,
            security_schemes: None,
            signatures: None,
            supports_authenticated_extended_card: None,
        }
    }

    pub fn with_protocol_version(mut self, version: String) -> Self {
        self.protocol_version = Some(version);
        self
    }

    pub fn with_icon_url(mut self, url: String) -> Self {
        self.icon_url = Some(url);
        self
    }

    pub fn with_documentation_url(mut self, url: String) -> Self {
        self.documentation_url = Some(url);
        self
    }

    pub fn with_provider(mut self, provider: AgentProvider) -> Self {
        self.provider = Some(provider);
        self
    }

    pub fn with_preferred_transport(mut self, transport: String) -> Self {
        self.preferred_transport = Some(transport);
        self
    }

    pub fn with_additional_interfaces(mut self, interfaces: Vec<AgentInterface>) -> Self {
        self.additional_interfaces = Some(interfaces);
        self
    }

    pub fn with_security(mut self, security: Vec<HashMap<String, Vec<String>>>) -> Self {
        self.security = Some(security);
        self
    }

    pub fn with_security_schemes(mut self, schemes: HashMap<String, SecurityScheme>) -> Self {
        self.security_schemes = Some(schemes);
        self
    }

    pub fn with_signatures(mut self, signatures: Vec<serde_json::Value>) -> Self {
        self.signatures = Some(signatures);
        self
    }

    pub fn with_supports_authenticated_extended_card(mut self, supports: bool) -> Self {
        self.supports_authenticated_extended_card = Some(supports);
        self
    }
}

/// Represents a single, stateful operation or conversation between a client and an agent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Task {
    /// A unique identifier (e.g. UUID) for the task, generated by the server for a new task
    pub id: String,
    /// A server-generated unique identifier (e.g. UUID) for maintaining context across multiple related tasks or interactions
    #[serde(rename = "context_id")]
    pub context_id: String,
    /// The current status of the task, including its state and a descriptive message
    pub status: TaskStatus,
    /// A collection of artifacts generated by the agent during the execution of the task
    pub artifacts: Option<Vec<Artifact>>,
    /// An array of messages exchanged during the task, representing the conversation history
    pub history: Option<Vec<Message>>,
    /// Optional metadata for extensions
    pub metadata: Option<HashMap<String, serde_json::Value>>,
    /// The type of this object, used as a discriminator. Always 'task'
    pub kind: String,
}

impl Task {
    pub fn new(context_id: String, status: TaskStatus) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            context_id,
            status,
            artifacts: None,
            history: None,
            metadata: None,
            kind: "task".to_string(),
        }
    }

    pub fn with_task_id(mut self, task_id: String) -> Self {
        self.id = task_id;
        self
    }

    pub fn with_artifacts(mut self, artifacts: Vec<Artifact>) -> Self {
        self.artifacts = Some(artifacts);
        self
    }

    pub fn with_history(mut self, history: Vec<Message>) -> Self {
        self.history = Some(history);
        self
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// An event sent by the agent to notify the client of a change in a task's status
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskStatusUpdateEvent {
    /// The ID of the task that was updated
    #[serde(rename = "task_id")]
    pub task_id: String,
    /// The context ID associated with the task
    #[serde(rename = "context_id")]
    pub context_id: String,
    /// The new status of the task
    pub status: TaskStatus,
    /// If true, this is the final event in the stream for this interaction
    pub r#final: bool,
    /// Optional metadata for extensions
    pub metadata: Option<HashMap<String, serde_json::Value>>,
    /// The type of this event, used as a discriminator. Always 'status-update'
    pub kind: String,
}

impl TaskStatusUpdateEvent {
    pub fn new(task_id: String, context_id: String, status: TaskStatus, r#final: bool) -> Self {
        Self {
            task_id,
            context_id,
            status,
            r#final,
            metadata: None,
            kind: "status-update".to_string(),
        }
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// An event sent by the agent to notify the client that an artifact has been generated or updated
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskArtifactUpdateEvent {
    /// The ID of the task this artifact belongs to
    #[serde(rename = "task_id")]
    pub task_id: String,
    /// The context ID associated with the task
    #[serde(rename = "context_id")]
    pub context_id: String,
    /// The artifact that was generated or updated
    pub artifact: Artifact,
    /// If true, the content of this artifact should be appended to a previously sent artifact with the same ID
    pub append: Option<bool>,
    /// If true, this is the final chunk of the artifact
    #[serde(rename = "last_chunk")]
    pub last_chunk: Option<bool>,
    /// Optional metadata for extensions
    pub metadata: Option<HashMap<String, serde_json::Value>>,
    /// The type of this event, used as a discriminator. Always 'artifact-update'
    pub kind: String,
}

impl TaskArtifactUpdateEvent {
    pub fn new(task_id: String, context_id: String, artifact: Artifact) -> Self {
        Self {
            task_id,
            context_id,
            artifact,
            append: None,
            last_chunk: None,
            metadata: None,
            kind: "artifact-update".to_string(),
        }
    }

    pub fn with_append(mut self, append: bool) -> Self {
        self.append = Some(append);
        self
    }

    pub fn with_last_chunk(mut self, last_chunk: bool) -> Self {
        self.last_chunk = Some(last_chunk);
        self
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// Defines authentication details for a push notification endpoint
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PushNotificationAuthenticationInfo {
    /// A list of supported authentication schemes (e.g., 'Basic', 'Bearer')
    pub schemes: Vec<String>,
    /// Optional credentials required by the push notification endpoint
    pub credentials: Option<String>,
}

impl PushNotificationAuthenticationInfo {
    pub fn new(schemes: Vec<String>) -> Self {
        Self {
            schemes,
            credentials: None,
        }
    }

    pub fn with_credentials(mut self, credentials: String) -> Self {
        self.credentials = Some(credentials);
        self
    }
}

/// Defines the configuration for setting up push notifications for task updates
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PushNotificationConfig {
    /// A unique identifier (e.g. UUID) for the push notification configuration, set by the client
    pub id: Option<String>,
    /// The callback URL where the agent should send push notifications
    pub url: Url,
    /// A unique token for this task or session to validate incoming push notifications
    pub token: Option<String>,
    /// Optional authentication details for the agent to use when calling the notification URL
    pub authentication: Option<PushNotificationAuthenticationInfo>,
}

impl PushNotificationConfig {
    pub fn new(url: Url) -> Self {
        Self {
            id: None,
            url,
            token: None,
            authentication: None,
        }
    }

    pub fn with_id(mut self, id: String) -> Self {
        self.id = Some(id);
        self
    }

    pub fn with_token(mut self, token: String) -> Self {
        self.token = Some(token);
        self
    }

    pub fn with_authentication(mut self, authentication: PushNotificationAuthenticationInfo) -> Self {
        self.authentication = Some(authentication);
        self
    }
}

/// A container associating a push notification configuration with a specific task
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskPushNotificationConfig {
    /// The unique identifier (e.g. UUID) of the task
    #[serde(rename = "task_id")]
    pub task_id: String,
    /// The push notification configuration for this task
    #[serde(rename = "push_notification_config")]
    pub push_notification_config: PushNotificationConfig,
}

impl TaskPushNotificationConfig {
    pub fn new(task_id: String, push_notification_config: PushNotificationConfig) -> Self {
        Self {
            task_id,
            push_notification_config,
        }
    }
}

/// Defines configuration options for a message/send or message/stream request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MessageSendConfiguration {
    /// A list of output MIME types the client is prepared to accept in the response
    #[serde(rename = "accepted_output_modes")]
    pub accepted_output_modes: Option<Vec<String>>,
    /// If true, the client will wait for the task to complete
    pub blocking: Option<bool>,
    /// The number of most recent messages from the task's history to retrieve in the response
    #[serde(rename = "history_length")]
    pub history_length: Option<i32>,
    /// Configuration for the agent to send push notifications for updates after the initial response
    #[serde(rename = "push_notification_config")]
    pub push_notification_config: Option<PushNotificationConfig>,
}

impl MessageSendConfiguration {
    pub fn new() -> Self {
        Self {
            accepted_output_modes: None,
            blocking: None,
            history_length: None,
            push_notification_config: None,
        }
    }

    pub fn with_accepted_output_modes(mut self, modes: Vec<String>) -> Self {
        self.accepted_output_modes = Some(modes);
        self
    }

    pub fn with_blocking(mut self, blocking: bool) -> Self {
        self.blocking = Some(blocking);
        self
    }

    pub fn with_history_length(mut self, length: i32) -> Self {
        self.history_length = Some(length);
        self
    }

    pub fn with_push_notification_config(mut self, config: PushNotificationConfig) -> Self {
        self.push_notification_config = Some(config);
        self
    }
}

/// Defines the parameters for a request to send a message to an agent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MessageSendParams {
    /// The message object being sent to the agent
    pub message: Message,
    /// Optional configuration for the send request
    pub configuration: Option<MessageSendConfiguration>,
    /// Optional metadata for extensions
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

impl MessageSendParams {
    pub fn new(message: Message) -> Self {
        Self {
            message,
            configuration: None,
            metadata: None,
        }
    }

    pub fn with_configuration(mut self, configuration: MessageSendConfiguration) -> Self {
        self.configuration = Some(configuration);
        self
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// Defines parameters containing a task ID, used for simple task operations
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskIdParams {
    /// The unique identifier (e.g. UUID) of the task
    pub id: String,
    /// Optional metadata associated with the request
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

impl TaskIdParams {
    pub fn new(id: String) -> Self {
        Self {
            id,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// Defines parameters for querying a task, with an option to limit history length
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TaskQueryParams {
    /// The unique identifier (e.g. UUID) of the task
    pub id: String,
    /// The number of most recent messages from the task's history to retrieve
    #[serde(rename = "history_length")]
    pub history_length: Option<i32>,
    /// Optional metadata associated with the request
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

impl TaskQueryParams {
    pub fn new(id: String) -> Self {
        Self {
            id,
            history_length: None,
            metadata: None,
        }
    }

    pub fn with_history_length(mut self, length: i32) -> Self {
        self.history_length = Some(length);
        self
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// Defines parameters for deleting a specific push notification configuration for a task
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteTaskPushNotificationConfigParams {
    /// The unique identifier (e.g. UUID) of the task
    pub id: String,
    /// The ID of the push notification configuration to delete
    #[serde(rename = "push_notification_config_id")]
    pub push_notification_config_id: String,
    /// Optional metadata associated with the request
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

impl DeleteTaskPushNotificationConfigParams {
    pub fn new(id: String, push_notification_config_id: String) -> Self {
        Self {
            id,
            push_notification_config_id,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// Defines parameters for fetching a specific push notification configuration for a task
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetTaskPushNotificationConfigParams {
    /// The unique identifier (e.g. UUID) of the task
    pub id: String,
    /// The ID of the push notification configuration to retrieve
    #[serde(rename = "push_notification_config_id")]
    pub push_notification_config_id: Option<String>,
    /// Optional metadata associated with the request
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

impl GetTaskPushNotificationConfigParams {
    pub fn new(id: String) -> Self {
        Self {
            id,
            push_notification_config_id: None,
            metadata: None,
        }
    }

    pub fn with_push_notification_config_id(mut self, config_id: String) -> Self {
        self.push_notification_config_id = Some(config_id);
        self
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// Defines parameters for listing all push notification configurations associated with a task
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ListTaskPushNotificationConfigParams {
    /// The unique identifier (e.g. UUID) of the task
    pub id: String,
    /// Optional metadata associated with the request
    pub metadata: Option<HashMap<String, serde_json::Value>>,
}

impl ListTaskPushNotificationConfigParams {
    pub fn new(id: String) -> Self {
        Self {
            id,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, metadata: HashMap<String, serde_json::Value>) -> Self {
        self.metadata = Some(metadata);
        self
    }
}

/// Represents a successful JSON-RPC response for the `message/stream` method
/// The server may send multiple response objects for a single request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SendStreamingMessageSuccessResponse {
    /// The identifier established by the client
    pub id: Option<serde_json::Value>,
    /// The version of the JSON-RPC protocol. MUST be exactly "2.0"
    pub jsonrpc: String,
    /// The result, which can be a Message, Task, or a streaming update event
    pub result: SendStreamingMessageResult,
}

impl SendStreamingMessageSuccessResponse {
    pub fn new(id: Option<serde_json::Value>, result: SendStreamingMessageResult) -> Self {
        Self {
            id,
            jsonrpc: "2.0".to_string(),
            result,
        }
    }
}

/// The result type for streaming message responses
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendStreamingMessageResult {
    Task(Task),
    Message(Message),
    TaskStatusUpdateEvent(TaskStatusUpdateEvent),
    TaskArtifactUpdateEvent(TaskArtifactUpdateEvent),
}

/// Represents a JSON-RPC response for the `message/stream` method
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendStreamingMessageResponse {
    Success(SendStreamingMessageSuccessResponse),
    Error(crate::a2a::jsonrpc::JSONRPCErrorResponse),
}

impl SendStreamingMessageResponse {
    pub fn success(id: Option<serde_json::Value>, result: SendStreamingMessageResult) -> Self {
        Self::Success(SendStreamingMessageSuccessResponse::new(id, result))
    }

    pub fn error(id: Option<serde_json::Value>, error: crate::a2a::jsonrpc::JSONRPCError) -> Self {
        Self::Error(crate::a2a::jsonrpc::JSONRPCErrorResponse::new(
            id.and_then(|id| {
                match id {
                    serde_json::Value::String(s) => Some(crate::a2a::jsonrpc::JSONRPCId::String(s)),
                    serde_json::Value::Number(n) => n.as_i64().map(crate::a2a::jsonrpc::JSONRPCId::Number),
                    serde_json::Value::Null => Some(crate::a2a::jsonrpc::JSONRPCId::Null),
                    _ => None,
                }
            }),
            error,
        ))
    }
}
